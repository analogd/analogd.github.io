// Project model - manages multiple design alternatives
// A project contains multiple designs for the same driver

export class Project {
    // Color palette for design visualization
    static DESIGN_COLORS = [
        '#58a6ff',  // Blue
        '#39d353',  // Green
        '#f0883e',  // Orange
        '#a371f7',  // Purple
        '#ff7b72',  // Red
        '#ffa657',  // Yellow
        '#56d4dd',  // Cyan
        '#d2a8ff',  // Lavender
    ];

    constructor(name = 'Untitled Project', driverId = null) {
        this.id = this._generateId();
        this.name = name;
        this.driverId = driverId;  // Shared across all designs
        this.designs = [];
        this.nextDesignNumber = 1;
    }

    // Generate unique ID
    _generateId() {
        return 'project-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    }

    // Add a new design to the project
    addDesign(designParams) {
        const design = {
            id: this._generateId(),
            name: designParams.name || this._generateAutoName(designParams),
            type: designParams.type,  // 'sealed' | 'ported'
            volume: designParams.volume,
            tuning: designParams.tuning || null,
            power: designParams.power || 500,
            portDiameter: designParams.portDiameter || null,
            portCount: designParams.portCount || 1,
            shownInGraph: designParams.shownInGraph !== false,  // Default true
            color: this._assignColor(),

            // Placeholder for calculated results (filled by app.js)
            results: null
        };

        this.designs.push(design);
        return design;
    }

    // Update an existing design
    updateDesign(designId, updates) {
        const design = this.designs.find(d => d.id === designId);
        if (!design) {
            throw new Error(`Design ${designId} not found`);
        }

        // Update params
        Object.assign(design, updates);

        // Regenerate name if params changed and name is auto-generated
        if (this._isAutoGeneratedName(design.name)) {
            design.name = this._generateAutoName(design);
        }

        return design;
    }

    // Remove a design
    removeDesign(designId) {
        const index = this.designs.findIndex(d => d.id === designId);
        if (index !== -1) {
            this.designs.splice(index, 1);
        }
    }

    // Fork a design (create a copy)
    forkDesign(designId) {
        const original = this.designs.find(d => d.id === designId);
        if (!original) {
            throw new Error(`Design ${designId} not found`);
        }

        const forked = {
            ...original,
            id: this._generateId(),
            name: original.name + ' (copy)',
            color: this._assignColor(),
            results: null  // Will be recalculated
        };

        this.designs.push(forked);
        return forked;
    }

    // Get designs that should be shown in graphs
    getVisibleDesigns() {
        return this.designs.filter(d => d.shownInGraph);
    }

    // Toggle design visibility in graphs
    toggleDesignVisibility(designId) {
        const design = this.designs.find(d => d.id === designId);
        if (!design) return false;

        // If turning on, check limit (max 5 visible)
        if (!design.shownInGraph) {
            const visibleCount = this.designs.filter(d => d.shownInGraph).length;
            if (visibleCount >= 5) {
                return false;  // Max visible reached
            }
        }

        design.shownInGraph = !design.shownInGraph;
        return true;
    }

    // Get design by ID
    getDesign(designId) {
        return this.designs.find(d => d.id === designId);
    }

    // Generate auto-name for design
    // Format: "{driver-short} {volume}L {type} {distinguisher}"
    _generateAutoName(design) {
        const driverShort = this.driverId ? this._getDriverShortName(this.driverId) : 'Driver';
        const volume = Math.round(design.volume);
        const type = design.type === 'ported' ? 'Ported' : 'Sealed';

        let name = `${driverShort} ${volume}L ${type}`;

        // Add distinguishers
        if (design.type === 'ported') {
            if (design.tuning) {
                name += ` @${Math.round(design.tuning)}Hz`;
            }
            if (design.portCount && design.portCount > 1) {
                name += ` (${design.portCount} ports)`;
            }
        }

        return name;
    }

    // Check if name looks auto-generated
    _isAutoGeneratedName(name) {
        // Auto-generated names contain "L Sealed" or "L Ported"
        return /\d+L (Sealed|Ported)/.test(name);
    }

    // Extract short driver name from ID
    _getDriverShortName(driverId) {
        // Examples:
        // "dayton-um18-22" → "UM18"
        // "dayton-umii18-22" → "UMII18"
        // "tc-sounds-lms-5400" → "LMS5400"

        const parts = driverId.split('-');

        // Look for pattern like "um18", "umii18", "lms"
        for (let i = 1; i < parts.length; i++) {
            const part = parts[i];
            if (/^[a-z]+\d+/.test(part)) {
                // Found pattern like "um18" or "lms5400"
                return part.toUpperCase().replace(/[^A-Z0-9]/g, '');
            }
        }

        // Fallback: use last part
        return parts[parts.length - 1].toUpperCase().substr(0, 6);
    }

    // Assign color from palette
    _assignColor() {
        const usedColors = new Set(this.designs.map(d => d.color));

        // Find first unused color
        for (const color of Project.DESIGN_COLORS) {
            if (!usedColors.has(color)) {
                return color;
            }
        }

        // All colors used, cycle back (shouldn't happen often)
        return Project.DESIGN_COLORS[this.designs.length % Project.DESIGN_COLORS.length];
    }

    // Serialize project for localStorage
    toJSON() {
        return {
            id: this.id,
            name: this.name,
            driverId: this.driverId,
            designs: this.designs,
            nextDesignNumber: this.nextDesignNumber
        };
    }

    // Deserialize project from localStorage
    static fromJSON(data) {
        const project = new Project(data.name, data.driverId);
        project.id = data.id;
        project.designs = data.designs || [];
        project.nextDesignNumber = data.nextDesignNumber || 1;
        return project;
    }

    // Create default empty project
    static createDefault() {
        return new Project('My Project', 'dayton-umii18-22');
    }
}
